<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Rem ‚Äî Companion (CI/CD Test)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0b0e14" />
<script type="importmap">
{
  "imports": {
    "three": "/static/vendor/three.module.js"
  }
}
</script>
<style>
  :root{ --fg:#f4f7ff; --glass:#0b1020dd; --line:#23314a; --green:#00d68f; --bg:#0b0e14; --pill:#13233c; --pillBorder:#2a3d59; --accent:#6366f1; --accent-light:#8b5cf6; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);overflow:hidden;-webkit-text-size-adjust:100%;-webkit-font-smoothing:antialiased}
  #scene3d{position:fixed;inset:0;z-index:0;background:radial-gradient(ellipse at center, #0f1419 0%, #0b0e14 100%);transition:all 0.5s ease}
  #scene3d.listening{background:radial-gradient(ellipse at center, #141a28 0%, #0b0e14 100%)}
  #scene3d.speaking{background:radial-gradient(ellipse at center, #1a1428 0%, #0b0e14 100%)}
  #panel{position:fixed;right:0;top:0;height:100%;width:min(380px,85vw);
         display:flex;flex-direction:column;gap:16px;padding:20px;
         background:linear-gradient(180deg,rgba(11,16,32,0.95),rgba(11,16,32,0.98));backdrop-filter:blur(20px);
    border-left:1px solid #2a3d59;z-index:2;box-shadow:-10px 0 30px rgba(0,0,0,0.3);
    transform:translateX(100%); transition:all .4s cubic-bezier(0.23, 1, 0.32, 1);
    overflow-y:auto;}
  #panel.open{ transform:translateX(0) }
  #log{flex:1;min-height:0;overflow:auto;padding-right:6px;scroll-behavior:smooth}
  .bubble{padding:14px 18px;border-radius:16px;margin:10px 0;border:1px solid #1e2a3f;line-height:1.6;word-wrap:break-word;transition:all 0.2s ease;position:relative}
  .bubble:hover{border-color:#3d4f73;transform:translateY(-1px)}
  .user{background:linear-gradient(135deg,#1a2851,#0f223f);border-left:3px solid var(--accent)}
  .bot{background:linear-gradient(135deg,#1a2433,#121a2a);animation:fadeInUp 0.3s ease-out}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  input,button,select{font:16px/1.35 inherit;padding:14px 16px;border-radius:12px;border:1px solid #1e2a3f;background:#101827;color:var(--fg);touch-action:manipulation;transition:all 0.2s ease}
  input{flex:1;min-width:0;} input:focus{border-color:var(--accent);box-shadow:0 0 0 3px rgba(99,102,241,0.1);outline:none}
  button{cursor:pointer;font-weight:600;position:relative;overflow:hidden}
  button:hover{filter:brightness(1.1);transform:translateY(-1px);box-shadow:0 4px 12px rgba(0,0,0,0.15)} 
  button:active{transform:translateY(0)}
  button:disabled{opacity:.55;cursor:not-allowed;transform:none}
  #voicebar{position:fixed;left:50%;bottom:calc(env(safe-area-inset-bottom, 0px) + 20px);z-index:2;display:flex;align-items:center;gap:8px;
            background:rgba(16,24,39,0.95);border:1px solid #2a3d59;padding:8px 16px;border-radius:20px;flex-wrap:wrap;
            max-width:calc(100vw - 32px);transform:translateX(-50%);backdrop-filter:blur(20px);box-shadow:0 8px 32px rgba(0,0,0,0.3)}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:8px 12px;border-radius:24px;background:var(--pill);border:1px solid var(--pillBorder);font-size:13px;color:#eaf2ff;min-height:36px;transition:all 0.2s ease;cursor:pointer}
  .pill:hover{background:#1a2a47;border-color:#3d4f73;transform:translateY(-1px)}
  .pill:focus-visible{outline:2px solid var(--accent);box-shadow:0 0 0 4px rgba(99,102,241,0.1)}
  .pill:active{transform:translateY(0)}
  select.pill{appearance:none;background:var(--pill);color:#eaf2ff}
  .dot{width:8px;height:8px;border-radius:50%;background:#78859a}.dot.on{background:var(--green);box-shadow:0 0 8px var(--green)}
  #badge{position:fixed;top:12px;left:12px;z-index:2;padding:6px 10px;border-radius:10px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700;letter-spacing:.3px;font-size:14px}
  #hambtn{position:fixed;top:12px;right:12px;z-index:3;padding:8px 10px;border-radius:10px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700;min-height:40px;min-width:40px}
  #subtitle{position:fixed;left:50%;bottom:20%;transform:translateX(-50%);z-index:2;
       max-width:min(85vw,700px); text-align:center; padding:8px 12px; border-radius:10px;
       background:#0e1627f5; border:1px solid #23314a; color:#e9f2ff; text-shadow:0 1px 2px #000; opacity:0; transition:opacity .3s ease;
       backdrop-filter:blur(8px)}
  #subtitle.show{ opacity:1 }
  #zoombar{position:fixed;left:12px;bottom:calc(env(safe-area-inset-bottom, 0px) + 80px);z-index:3;display:flex;flex-direction:column;gap:6px}
  #zoombar button{padding:6px 8px;border-radius:8px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700;color:var(--fg);min-height:36px;min-width:36px}
  #disclaimer{position:fixed;left:50%;top:8px;transform:translateX(-50%);z-index:3;
    padding:6px 10px;border-radius:8px;border:1px solid #2a3a55;background:#0b1020e6;color:#c6d6ec;
    font-size:12px;max-width:calc(100vw - 16px);text-align:center}
  body.large-text { font-size:18px }
  body.large-text input, body.large-text button { font-size:18px }
  body.high-contrast { --fg:#ffffff; --bg:#0a0d14 }
  body.high-contrast .bubble { border-color:#35507a }
  body.high-contrast .user { background:#0d2a52 }
  body.high-contrast .bot  { background:#0f1930 }
  
  @keyframes fadeInUp { from {opacity:0;transform:translateY(20px)} to {opacity:1;transform:translateY(0)} }
  @keyframes pulse { 0%,100% {opacity:1} 50% {opacity:0.7} }
  @keyframes breathe { 0%,100% {transform:scale(1)} 50% {transform:scale(1.02)} }
  
  .breathing { animation: breathe 4s ease-in-out infinite }
  .listening { animation: pulse 1.5s ease-in-out infinite }
  .typing { animation: fadeInUp 0.3s ease-out }
  @media (max-width: 768px){
    #panel{width:100vw; padding:16px; border-left:none; border-top:1px solid #2a3d59; gap:12px; padding-bottom:calc(env(safe-area-inset-bottom, 0px) + 80px);}
    #badge{font-size:12px; padding:4px 8px; top:auto; bottom:calc(env(safe-area-inset-bottom, 0px) + 100px)}
    #subtitle{bottom:35%; font-size:14px; padding:8px 12px}
    #voicebar{left:50%; bottom:calc(env(safe-area-inset-bottom, 0px) + 16px); padding:6px 12px; gap:6px}
    .pill{font-size:12px; padding:6px 10px; min-height:32px}
    input,button,select{font-size:16px; padding:12px 14px; min-height:48px}
    .bubble{padding:12px 16px; margin:8px 0; font-size:15px}
    #hambtn{min-height:40px; min-width:40px; padding:8px 10px; backdrop-filter:blur(20px)}
    #zoombar{display:none}
    .row{gap:8px}
    #disclaimer{font-size:11px; padding:4px 8px}
  }
  @media (max-width: 480px){
    #panel{padding:8px; padding-bottom:calc(env(safe-area-inset-bottom, 0px) + 80px);}
    #voicebar{padding:2px 4px; gap:2px}
    .pill{font-size:11px; padding:3px 6px; min-height:24px}
    input,button,select{font-size:16px; padding:8px 10px; min-height:40px}
    .bubble{padding:8px 12px; font-size:14px}
    #subtitle{font-size:13px}
  }
</style>
</head>
<body>
  <div id="scene3d">
    <div id="loading-overlay" style="position:absolute;inset:0;display:grid;place-items:center;color:#9fb3d1;background:rgba(11,14,20,0.8);backdrop-filter:blur(4px);z-index:1;transition:opacity 0.5s ease">
      <div style="text-align:center">
        <div style="margin-bottom:16px;font-size:18px">Loading 3D Avatar‚Ä¶</div>
        <div style="width:40px;height:40px;border:3px solid #334155;border-top-color:#6366f1;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto"></div>
      </div>
    </div>
  </div>
  <style>
    @keyframes spin { to { transform: rotate(360deg) } }
  </style>
  <div id="badge">Rem</div>
  <button id="hambtn">‚ò∞</button>
  <div id="subtitle" aria-live="polite"></div>
  <div id="disclaimer">Preview build: This experience is under active development and may be imperfect.</div>

  <aside id="panel">
    <div style="font-weight:700;letter-spacing:.4px;font-size:18px;margin-bottom:8px">üí¨ Chat with Rem</div>
    <div id="current-mode" style="font-size:12px;color:#78859a;margin-bottom:16px;padding:4px 8px;background:rgba(99,102,241,0.1);border-radius:8px;border:1px solid rgba(99,102,241,0.2);">Mode: Default</div>
    
    <div id="log"></div>
    
    <div class="row" style="margin-top:16px">
      <input id="inp" placeholder="Type your message‚Ä¶" />
      <button id="send" style="background:var(--accent);border-color:var(--accent)">Send</button>
    </div>
    
    <!-- Simplified personality modes -->
    <div style="font-weight:600;letter-spacing:.3px;margin:20px 0 8px 0;font-size:14px">üé≠ Personality</div>
    <div class="row" style="flex-wrap:wrap;gap:8px;margin-bottom:16px">
      <button class="pill style" data-style="witty" title="Humorous and playful">‚ú® Witty</button>
      <button class="pill style" data-style="empathetic" title="Caring and supportive">üíû Caring</button>
      <button class="pill style" data-style="precise" title="Direct and focused">üß† Precise</button>
      <button class="pill" id="resetStyle" title="Default friendly mode">üîÑ Default</button>
    </div>
    
    <!-- Quick actions -->
    <div style="font-weight:600;letter-spacing:.3px;margin:20px 0 8px 0;font-size:14px">‚ö° Quick Actions</div>
    <div class="row" style="flex-wrap:wrap;gap:8px;margin-bottom:16px">
      <button class="pill" data-say="Tell me an inspiring story">ÔøΩ Story</button>
      <button class="pill" data-say="Help me relax with a breathing exercise">ÔøΩ Relax</button>
      <button class="pill" data-say="Share a fascinating fact">ÔøΩ Learn</button>
    </div>
    
    <!-- Singing section (simplified) -->
    <div style="font-weight:600;letter-spacing:.3px;margin:20px 0 8px 0;font-size:14px">üéµ Voice & Music</div>
    <div class="row">
      <input id="singinp" placeholder="What should I sing about?" />
      <button id="singGo" style="background:var(--accent-light);border-color:var(--accent-light)">Sing</button>
    </div>
  </aside>

  <div id="voicebar">
    <button id="mic" class="pill" style="background:var(--accent);border-color:var(--accent)">üéôÔ∏è Talk</button>
    <button id="stop" class="pill" disabled style="background:#dc2626;border-color:#dc2626">‚ñ† Stop</button>
    <span class="pill" style="background:rgba(0,0,0,0.3);border-color:rgba(255,255,255,0.1)">
      <span id="micdot" class="dot"></span>
      <span id="miclabel" style="font-weight:500">Ready</span>
    </span>
    <select id="langsel" class="pill" title="Voice language" style="min-width:80px">
      <option value="auto" selected>Auto</option>
      <option value="en">English</option>
      <option value="es">Espa√±ol</option>
      <option value="fr">Fran√ßais</option>
      <option value="hi">‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
    </select>
  </div>

  <!-- Zoom controls -->
  <div id="zoombar" aria-label="Viewport zoom controls">
    <button id="zoomIn" title="Zoom in">Ôºã</button>
    <button id="zoomOut" title="Zoom out">Ôºç</button>
    <button id="zoomReset" title="Reset view">‚ü≥</button>
  </div>


<script type="module">
const RPM_AVATAR_URL = "/static/models/blessedboy.glb";

import * as THREE from "three";
import { GLTFLoader }  from "/static/vendor/GLTFLoader.js";
import { DRACOLoader } from "/static/vendor/DRACOLoader.js";
import { OrbitControls } from "/static/vendor/OrbitControls.js";
const elements = {
  scene3d: document.getElementById('scene3d'),
  log: document.getElementById('log'),
  inp: document.getElementById('inp'),
  send: document.getElementById('send'),
  mic: document.getElementById('mic'),
  stop: document.getElementById('stop'),
  sing: document.getElementById('sing'),
  langsel: document.getElementById('langsel'),
  micdot: document.getElementById('micdot'),
  miclabel: document.getElementById('miclabel'),
  panel: document.getElementById('panel'),
  hambtn: document.getElementById('hambtn'),
  subtitle: document.getElementById('subtitle'),
  singinp: document.getElementById('singinp'),
  singGo: document.getElementById('singGo'),
  zoomIn: document.getElementById('zoomIn'),
  zoomOut: document.getElementById('zoomOut'),
  zoomReset: document.getElementById('zoomReset')
};
const suggestionButtons = () => Array.from(document.querySelectorAll('#panel .pill[data-say]'));
const styleButtons = () => Array.from(document.querySelectorAll('#panel .pill.style'));

const typingEl = Object.assign(document.createElement('div'), {
  className: 'bubble bot',
  textContent: '‚Ä¶',
  style: { opacity: '0.6' }
});
let selectedStyle = null;

try{
  const prefs = {
    largeText: localStorage.getItem('pref-large-text') === '1',
    highContrast: localStorage.getItem('pref-high-contrast') === '1'
  };
  document.body.classList.toggle('large-text', prefs.largeText);
  document.body.classList.toggle('high-contrast', prefs.highContrast);
}catch{}

function add(text, who){
  try {
    // Clean the text for display (remove stage directions and name prefixes)
    const cleanText = who === 'bot' ? sanitizeCaption(text) : text;
    const d = Object.assign(document.createElement('div'), {
      className: 'bubble ' + who,
      textContent: cleanText
    });
    
    if (elements.log) {
      elements.log.appendChild(d);
      d.scrollIntoView({behavior:'smooth', block:'end'});
    } else {
      console.error('‚ùå Chat log element not found!');
    }
  } catch (error) {
    console.error('‚ùå Error adding chat message:', error);
  }
}

let renderer, scene, camera, controls, clock;
let jawTargets=[], smileTargets=[], blinkLeftTargets=[], blinkRightTargets=[], blinkBothTargets=[], headBone=null, jawBone=null, root=null;
let eyeLeftBone=null, eyeRightBone=null;
let jawEnergy=0, threeReady=false;
let smile=0, blink=0, nextBlinkT=0, lastT=0, prevSmileLevel=0;
let entrance = { active: true, startT: 0, fromZ: 0, toZ: 0 };
let exprPulse = { smile: 0, winkL: 0, winkR: 0 };
let gaze = { x: 0, y: 0, t: 0 };
let breathingState = { phase: 0, intensity: 0.3 };
let interactionState = { isListening: false, isSpeaking: false, isThinking: false };
let emotionalState = { happiness: 0.1, engagement: 0.5, energy: 0.7 };

function setJawEnergy(level){ jawEnergy = Math.max(0, Math.min(1, level)); }
function setSmile(level){ smile = Math.max(0, Math.min(1, level)); }
function setBlink(level){ blink = Math.max(0, Math.min(1, level)); }

// Enhanced avatar state controls (Grok AI style)
function setListening(isListening){ 
  interactionState.isListening = isListening;
  elements.scene3d.classList.toggle('listening', isListening);
  if(isListening) emotionalState.engagement = Math.min(1, emotionalState.engagement + 0.2);
}
function setSpeaking(isSpeaking){ 
  interactionState.isSpeaking = isSpeaking;
  elements.scene3d.classList.toggle('speaking', isSpeaking);
  if(isSpeaking) emotionalState.energy = Math.min(1, emotionalState.energy + 0.1);
}
function setHappiness(level){ emotionalState.happiness = Math.max(0, Math.min(1, level)); }
function setEngagement(level){ emotionalState.engagement = Math.max(0, Math.min(1, level)); }
function triggerExpression(type, intensity = 1.0){
  switch(type){
    case 'smile': exprPulse.smile = intensity; setHappiness(emotionalState.happiness + 0.1); break;
    case 'wink': exprPulse.winkL = intensity; break;
    case 'surprise': setEngagement(1.0); breathingState.intensity = 0.5; break;
    case 'thinking': interactionState.isThinking = true; setTimeout(() => interactionState.isThinking = false, 2000); break;
  }
}

function frameObject(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(), center = new THREE.Vector3();
  box.getSize(size); box.getCenter(center);
  center.y += size.y*0.28;
  const dist = (size.y*0.55) / Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5));
  camera.position.set(center.x, center.y + 0.06, center.z + dist*0.48);
  camera.lookAt(center);
  controls.target.copy(center); controls.update();
}
function faceCameraIfBackwards(){
  if(!headBone || !root) return;
  const fwd = new THREE.Vector3(0,0,1);
  headBone.getWorldDirection(fwd);
  const toCam = new THREE.Vector3().subVectors(camera.position, headBone.getWorldPosition(new THREE.Vector3())).normalize();
  if (fwd.dot(toCam) < 0) root.rotateY(Math.PI);
}

async function init3D(url){
  console.log('üéÆ init3D called with URL:', url);
  
  if (!elements.scene3d) {
    throw new Error('scene3d element not found');
  }
  
  const w = elements.scene3d.clientWidth, h = elements.scene3d.clientHeight;
  console.log('üìê Scene dimensions:', w, 'x', h);
  
  if (w === 0 || h === 0) {
    throw new Error('Scene element has no dimensions');
  }
  
  console.log('üé® Creating WebGL renderer...');
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setSize(w, h);
  
  try{
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.physicallyCorrectLights = true;
    console.log('‚úÖ Renderer settings applied');
  }catch(rendererError){
    console.warn('‚ö†Ô∏è Some renderer settings failed:', rendererError);
  }
  
  elements.scene3d.innerHTML=''; 
  elements.scene3d.appendChild(renderer.domElement);
  console.log('üñºÔ∏è Renderer canvas added to DOM');

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(24, w/h, 0.1, 100);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
  const dir  = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(1,1,1);
  scene.add(hemi, dir);

  controls = new OrbitControls(camera, renderer.domElement);
  // Allow user zoom in/out with mouse wheel or pinch
  controls.enableZoom = true; controls.zoomSpeed = 0.7; controls.enablePan = false;
  controls.minDistance = 0.8; controls.maxDistance = 6;

  clock = new THREE.Clock();
  const loader = new GLTFLoader();
  const draco  = new DRACOLoader();
  draco.setDecoderPath("/static/vendor/draco/");
  loader.setDRACOLoader(draco);

  const gltf = await loader.loadAsync(url);
  root = gltf.scene; scene.add(root);

  // Increase texture filtering quality
  try{
    const aniso = renderer.capabilities.getMaxAnisotropy?.() || 8;
    root.traverse(o=>{
      const m = o.material; if(!m) return;
      const tx = ['map','normalMap','metalnessMap','roughnessMap','emissiveMap','aoMap'];
      for(const k of tx){ if(m[k]) m[k].anisotropy = aniso; }
    });
  }catch{}

  root.traverse(o=>{
    if (/head\b/i.test(o.name) && !headBone) headBone = o;
    if (!jawBone && /\b(jaw|mouth)\b/i.test(o.name)) jawBone = o; // fallback bone-based jaw
    // Eye bones (common names): Eye.L/Eye.R, eye_l/eye_r, LeftEye/RightEye
    if (!eyeLeftBone && /eye[._\s-]*l|left\s*eye/i.test(o.name)) eyeLeftBone = o;
    if (!eyeRightBone && /eye[._\s-]*r|right\s*eye/i.test(o.name)) eyeRightBone = o;
    if (o.isMesh && o.morphTargetDictionary && o.morphTargetInfluences){
      const dict = o.morphTargetDictionary;
      for (const key in dict){
        const idx = dict[key]; const k = key.toLowerCase();
        // Jaw / mouth open
        if (/jaw|mouth\s*open|openmouth|aa\b|ah\b|aah|big_ah|vowel_ah/.test(k)) {
          jawTargets.push({ mesh:o, idx });
        }
        // Smile variants
        if (/smile|mouth\s*smile|smileleft|smileright|mouthcornerpull|happy|smirk/.test(k)) {
          smileTargets.push({ mesh:o, idx });
        }
        // Blink variants
        const blinkLike = /blink|eyelid|eye\s*close|eyesclosed|closeeye|eye\s*shut/.test(k);
        if (blinkLike) {
          const isLeft = /left|\bl\b|_l|\.l|eye_l|eye\.l|blinkl/.test(k);
          const isRight = /right|\br\b|_r|\.r|eye_r|eye\.r|blinkr/.test(k);
          if (isLeft) blinkLeftTargets.push({ mesh:o, idx });
          else if (isRight) blinkRightTargets.push({ mesh:o, idx });
          else blinkBothTargets.push({ mesh:o, idx });
        }
      }
    }
  });

  frameObject(root);
  faceCameraIfBackwards();

  // Entrance: start slightly forward and move toward camera
  entrance.startT = clock.getElapsedTime();
  entrance.fromZ = (root.position.z || 0) + 0.9;
  entrance.toZ = root.position.z || 0;
  root.position.z = entrance.fromZ;

  function loop(){
    const t = clock.getElapsedTime();
    const dt = clock.getDelta();
    
    // Enhanced breathing animation (like Grok AI)
    breathingState.phase += dt * (0.8 + emotionalState.energy * 0.4);
    const breathCycle = Math.sin(breathingState.phase) * breathingState.intensity;
    
    // Dynamic idle motion based on emotional state
    const baseYaw = Math.sin(t*0.4) * (0.08 + emotionalState.engagement * 0.04);
    const baseBob = Math.sin(t*0.7) * (0.03 + emotionalState.energy * 0.02);
    const breathBob = breathCycle * 0.015;
    
    // Listening micro-movements
    const listenSway = interactionState.isListening ? Math.sin(t*1.2) * 0.02 : 0;
    const speakBounce = interactionState.isSpeaking ? Math.sin(t*2.5) * 0.03 : 0;
    
    if (root){
      // Entrance easing (improved with bounce)
      if (entrance.active){
        const dt = t - entrance.startT;
        const dur = 2.8; const p = Math.min(1, dt/dur); 
        const bounce = 1 + Math.sin(p * Math.PI) * 0.1;
        const e = 1 - Math.pow(1-p, 3) * bounce;
        root.position.z = entrance.fromZ + (entrance.toZ - entrance.fromZ)*e;
        if (p >= 1) entrance.active = false;
      }
      
      // Apply combined movements
      root.rotation.y = baseYaw + listenSway;
      root.position.y = (baseBob + breathBob + speakBounce) * (entrance.active ? 1.5 : 1.0);
      
      // Slight forward lean when engaged
      root.rotation.x = THREE.MathUtils.lerp(root.rotation.x, emotionalState.engagement * 0.05, 0.1);
    }

    // Head motion: slight idle nod + speech-driven component
    const idleNod = Math.sin(t*0.8) * 0.035;     // ~¬±2¬∞
    const speakNod = (jawEnergy-0.12) * 0.06;   // a bit stronger while speaking
    if (headBone) headBone.rotation.x = THREE.MathUtils.lerp(headBone.rotation.x, idleNod + speakNod, 0.15);

  // Apply mouth openness to detected morph targets (or rotate jaw bone if no morphs)
    if (jawTargets.length){
      for (const j of jawTargets){ j.mesh.morphTargetInfluences[j.idx] = jawEnergy; }
    } else if (jawBone) {
      const maxOpen = THREE.MathUtils.degToRad(12); // ~12¬∞
      jawBone.rotation.x = THREE.MathUtils.lerp(jawBone.rotation.x, jawEnergy * maxOpen, 0.2);
    }

  // Enhanced smile with emotional state influence
    const baseSmile = emotionalState.happiness * 0.15;
    const idleSmile = baseSmile + Math.max(0, Math.sin(t*0.6))*0.05;
    const speakSmile = jawEnergy * 0.4;
    const engagementSmile = emotionalState.engagement * 0.1;
    exprPulse.smile = Math.max(0, exprPulse.smile - 0.025);
    const sLevel = THREE.MathUtils.clamp(idleSmile + speakSmile + engagementSmile + exprPulse.smile*0.7 + smile*0.3, 0, 0.85);
  let appliedSmile = false;
  for (const s of smileTargets){ s.mesh.morphTargetInfluences[s.idx] = THREE.MathUtils.lerp(s.mesh.morphTargetInfluences[s.idx]||0, sLevel, 0.1); appliedSmile = true; }
  // If no smile morphs exist, emulate expression subtly by head tilt
  if (!appliedSmile && headBone){ headBone.rotation.z = THREE.MathUtils.lerp(headBone.rotation.z, (jawEnergy*0.08) * (Math.sin(t*0.6)*0.4), 0.08); }

    // Natural blinking (more frequent, random length)
    if (t > nextBlinkT){ nextBlinkT = t + 2.8 + Math.random()*2.8; lastT = t; }
    const bDur = 0.24 + Math.random()*0.08; // 0.24‚Äì0.32s
    const bPhase = Math.max(0, 1 - Math.abs((t-lastT) - bDur*0.5)/(bDur*0.5));
    const bLevel = THREE.MathUtils.clamp(bPhase, 0, 1);
    let hasBlinkMorph = false;
    for (const b of blinkLeftTargets){ b.mesh.morphTargetInfluences[b.idx] = bLevel; hasBlinkMorph = true; }
    for (const b of blinkRightTargets){ b.mesh.morphTargetInfluences[b.idx] = bLevel; hasBlinkMorph = true; }
    for (const b of blinkBothTargets){ b.mesh.morphTargetInfluences[b.idx] = bLevel; hasBlinkMorph = true; }
    // If no blink morphs, do a tiny eye-bone blink emulation (pitch down and back)
    if (!hasBlinkMorph && (eyeLeftBone||eyeRightBone)){
      const e = (bLevel*0.12);
      if (eyeLeftBone) eyeLeftBone.rotation.x = THREE.MathUtils.lerp(eyeLeftBone.rotation.x, e, 0.25);
      if (eyeRightBone) eyeRightBone.rotation.x = THREE.MathUtils.lerp(eyeRightBone.rotation.x, e, 0.25);
    }

    // Eye saccades: subtle gaze shifts if eye bones exist
    if ((eyeLeftBone || eyeRightBone) && headBone){
      gaze.t -= clock.getDelta();
      if (gaze.t <= 0){
        gaze.t = 0.6 + Math.random()*1.2;
        gaze.x = (Math.random()*2-1) * 0.12; // ¬±0.12 rad
        gaze.y = (Math.random()*2-1) * 0.08; // ¬±0.08 rad
      }
      const gx = gaze.x, gy = gaze.y;
      if (eyeLeftBone){ eyeLeftBone.rotation.y = THREE.MathUtils.lerp(eyeLeftBone.rotation.y, gx, 0.08);
                        eyeLeftBone.rotation.x = THREE.MathUtils.lerp(eyeLeftBone.rotation.x, gy, 0.08); }
      if (eyeRightBone){ eyeRightBone.rotation.y = THREE.MathUtils.lerp(eyeRightBone.rotation.y, gx, 0.08);
                         eyeRightBone.rotation.x = THREE.MathUtils.lerp(eyeRightBone.rotation.x, gy, 0.08); }
    }

    // Smile indicator
    if (sLevel > 0.33 && prevSmileLevel <= 0.33) { showSubtitle('[smiles]', 1200); exprPulse.smile = 1.0; }
    prevSmileLevel = sLevel;

    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  loop();

  window.addEventListener('resize', ()=>{
    const W = elements.scene3d.clientWidth, H = elements.scene3d.clientHeight;
    renderer.setSize(W,H); camera.aspect = W/H; camera.updateProjectionMatrix();
    if (root) frameObject(root);
  });

  // Pointer-driven subtle gaze targeting (if eye bones exist)
  let lastPointerAt = 0;
  window.addEventListener('pointermove', (ev)=>{
    if(!(eyeLeftBone||eyeRightBone)) return;
    const x = ev.clientX / window.innerWidth;
    const y = ev.clientY / window.innerHeight;
    gaze.x = (x - 0.5) * 0.22;   // left/right
    gaze.y = (0.5 - y) * 0.14;   // up/down
    gaze.t = 0.6;                // hold this target for a bit
    lastPointerAt = performance.now();
  }, {passive:true});

  threeReady = true;
}
function schedule3D(){
  console.log('üé¨ Scheduling 3D initialization...');
  const start = ()=> {
    console.log('üöÄ Starting 3D load with URL:', RPM_AVATAR_URL);
    return init3D(RPM_AVATAR_URL)
      .then(() => {
        console.log('‚úÖ 3D load successful!');
        threeReady = true;
        // Hide loading overlay
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) {
          loadingOverlay.style.opacity = '0';
          setTimeout(() => loadingOverlay.remove(), 500);
        }
      })
      .catch(async (err)=>{
        console.warn("‚ùå Primary 3D load failed:", err);
        console.log("üîÑ Trying fallback path...");
        try{
          await init3D('/static/models/blessedboy.glb');
          console.log('‚úÖ Fallback 3D load successful!');
          threeReady = true;
          // Hide loading overlay
          const loadingOverlay = document.getElementById('loading-overlay');
          if (loadingOverlay) {
            loadingOverlay.style.opacity = '0';
            setTimeout(() => loadingOverlay.remove(), 500);
          }
        }catch(e2){
          console.error("üí• Fallback 3D load also failed:", e2);
          const overlay = elements.scene3d.querySelector('div');
          if(overlay) overlay.textContent = '3D failed to load. Error: ' + e2.message;
        }
      })
      .finally(()=>{
        console.log('üé≠ Re-enabling pointer events on scene3d');
        elements.scene3d.style.pointerEvents = "auto";
      });
  };
  (window.requestIdleCallback || ((f)=>setTimeout(f,250)))(start);
}
elements.scene3d.style.pointerEvents = "none";

// Debug 3D loading
console.log('üéØ Starting 3D initialization...');
console.log('Elements:', elements);
console.log('Scene3D element:', elements.scene3d);

try{
  const test = document.createElement('canvas').getContext('webgl') || document.createElement('canvas').getContext('experimental-webgl');
  console.log('WebGL test:', test ? 'SUPPORTED' : 'NOT SUPPORTED');
  
  if(!test){
    const overlay = elements.scene3d.querySelector('div');
    if(overlay) overlay.textContent = 'WebGL not supported. Try a newer browser or update graphics drivers.';
  }else{
    console.log('üì± WebGL supported, starting 3D loading...');
    schedule3D();
    setTimeout(()=>{
      console.log('‚è∞ 8-second timeout check. ThreeReady:', threeReady);
      if(!threeReady){
        const overlay = elements.scene3d.querySelector('div');
        if(overlay) {
          overlay.textContent = 'Still loading 3D‚Ä¶ Check browser console for errors.';
          console.error('‚ùå 3D failed to load within 8 seconds');
        }
      }
    }, 8000);
  }
}catch(error){
  console.error('üí• 3D initialization error:', error);
  const overlay = elements.scene3d.querySelector('div');
  if(overlay) overlay.textContent = '3D init error. Check console for details: ' + error.message;
}

let curTtsCtrl = null;
let selectedLang = 'auto';
let lastLangHint = 'en';

const langPatterns = {
  en: [' the ', ' and ', ' you ', ' hello', ' hi '],
  es: [' el ', ' la ', ' de ', ' que ', ' y ', ' como ', ' gracias', ' por ', ' puedo ', ' hola '],
  fr: [' le ', ' la ', ' des ', ' et ', ' je ', ' vous ', ' bonjour', ' merci', ' avec ']
};

function detectLang(s){
  const t = (s||'').trim();
  if(!t) return lastLangHint || 'en';
  if(/[\u0900-\u097F]/.test(t)) return 'hi';
  
  const lower = t.toLowerCase();
  const score = {en:0, es:0, fr:0};
  
  for(const [lang, patterns] of Object.entries(langPatterns)){
    patterns.forEach(w => { if(lower.includes(w)) score[lang]++; });
  }
  
  if(/[√°√©√≠√≥√∫√±¬°¬ø]/i.test(t)) score.es+=2;
  if(/[√†√¢√ß√©√®√™√´√Æ√Ø√¥√π√ª√º√ø≈ì]/i.test(t)) score.fr+=2;
  
  let best='en', bestV=-1;
  for(const k in score){ if(score[k]>bestV){ best=k; bestV=score[k]; } }
  return bestV<=0 ? (lastLangHint || 'en') : best;
}
function ttsPayload(text){
  let lang = selectedLang || 'en';
  if(lang === 'auto'){
    lang = detectLang(text);
    lastLangHint = lang || lastLangHint;
  }
  const mode = lang !== 'en' ? 'auto' : null; // keep Ruth for English by default
  return { text, lang, mode };
}
async function ttsFull(text){
  // Retry a couple times on 429/5xx to smooth out transient throttling
  let lastErr;
  for(let attempt=0; attempt<3; attempt++){
    try{
  const ctrl = new AbortController(); curTtsCtrl = ctrl;
  const timeout = setTimeout(()=>{ try{ ctrl.abort(); }catch{} }, 30000);
      const r = await fetch('/api/tts',{
        method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(ttsPayload(text)), signal: ctrl.signal
      });
  clearTimeout(timeout);
      if(r.status===429 || r.status===503 || r.status===502){
        const back = 250*Math.pow(2,attempt) + Math.random()*150; await new Promise(res=>setTimeout(res, back));
        continue;
      }
      const d = await r.json(); return d; // {audio_b64, marks}
    }catch(e){
      if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){ throw e; }
      lastErr = e; const back = 200*Math.pow(2,attempt); await new Promise(res=>setTimeout(res, back));
    } finally {
      curTtsCtrl = null;
    }
  }
  throw lastErr || new Error('tts-retries-exhausted');
}

async function singOnce(text){
  let lastErr;
  for(let attempt=0; attempt<3; attempt++){
    try{
      const ctrl = new AbortController(); curTtsCtrl = ctrl;
  const timeout = setTimeout(()=>{ try{ ctrl.abort(); }catch{} }, 30000);
      const r = await fetch('/api/sing',{
        method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(ttsPayload(text)), signal: ctrl.signal
      });
      clearTimeout(timeout);
      if(r.status===429 || r.status===503 || r.status===502){
        const back = 250*Math.pow(2,attempt) + Math.random()*150; await new Promise(res=>setTimeout(res, back));
        continue;
      }
      const d = await r.json(); return d; // {audio_b64, marks}
    }catch(e){
      if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){ throw e; }
      lastErr = e; const back = 200*Math.pow(2,attempt); await new Promise(res=>setTimeout(res, back));
    } finally { curTtsCtrl = null; }
  }
  throw lastErr || new Error('sing-retries-exhausted');
}

let speaking=false, currentAudio=null, audioCtx=null, raf=null;
let curStreamCtrl = null;
let autoResumeMic = false;
let suppressASRUntil = 0;
function stopSpeaking(){
  speaking=false; setSpeaking(false);
  try{ if(currentAudio){ currentAudio.pause(); currentAudio.src=''; } }catch{}
  if(raf) cancelAnimationFrame(raf); currentAudio=null;
  setJawEnergy(0);
  if(audioCtx){ try{ audioCtx.close(); }catch{} audioCtx=null; }
  try{ if(window.speechSynthesis){ window.speechSynthesis.cancel(); } }catch{}
  // Flush any queued utterances so a new prompt starts fresh
  try{ speakQ = Promise.resolve(); }catch{}
  // Abort any active streaming request so it doesn't enqueue more sentences
  try{ if(curStreamCtrl){ curStreamCtrl.abort(); curStreamCtrl = null; } }catch{}
  // Abort any active TTS fetch
  try{ if(curTtsCtrl){ curTtsCtrl.abort(); curTtsCtrl = null; } }catch{}
}
const VMAP = { "sil":0.00, "p":0.15, "t":0.2, "f":0.22, "k":0.22, "S":0.2, "T":0.22, "r":0.28, "w":0.3,
               "e":0.55, "i":0.6, "o":0.75, "u":0.78, "@":0.5, "a":0.95 };
function visemeToOpen(v){ return (VMAP[v] ?? 0.35); }

async function playAudioWithVisemes(b64, marks){
  return new Promise(async (resolve, reject)=>{
    stopSpeaking(); speaking=true; setSpeaking(true);
    // Keep mic active; just suppress ASR results while speaking
    suppressASRUntil = Number.POSITIVE_INFINITY;
    const audio = new Audio('data:audio/mp3;base64,'+b64); currentAudio=audio;

    let cleaned=false;
    const cleanup=(endOk=true)=>{
      if(cleaned) return; cleaned=true;
      try{ if(raf) cancelAnimationFrame(raf); }catch{}
      setJawEnergy(0);
      try{ audio.pause(); audio.src=''; }catch{}
      try{ if(audioCtx){ audioCtx.close(); } }catch{}
      audioCtx = null; currentAudio = null; speaking = false;
  // After TTS ends, ignore ASR results briefly (slightly longer to avoid overlap)
  suppressASRUntil = performance.now() + 1000;
      endOk ? resolve() : reject(new Error('audio-playback-failed'));
    };

    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const src = audioCtx.createMediaElementSource(audio);
      const an  = audioCtx.createAnalyser(); an.fftSize=512;
      src.connect(an); an.connect(audioCtx.destination);

      try{ if(audioCtx.state!=='running') await audioCtx.resume(); }catch{}
      let started=false;
      audio.onplay = ()=>{ started=true; };
      audio.onerror = ()=> cleanup(false);
      const startWatch = setTimeout(()=>{ if(!started) cleanup(false); }, 2500);
  audio.onended = ()=>{ clearTimeout(startWatch); cleanup(true); };
  // If we interrupt (stopSpeaking pauses audio), treat as a clean end so the queue continues
  audio.onpause = ()=>{ clearTimeout(startWatch); cleanup(true); };
      audio.play().catch(()=> cleanup(false));

      let idx=0, target=0.2, level=0.15;
      const startAt = audioCtx.currentTime;
      const data = new Uint8Array(an.frequencyBinCount);

      const tick=()=>{
        if(!speaking || cleaned) return;
        const tms = (audioCtx.currentTime - startAt)*1000;

        while(Array.isArray(marks) && idx<marks.length && marks[idx].time <= tms + 30){
          target = visemeToOpen(marks[idx].value); idx++;
        }

        an.getByteTimeDomainData(data);
        let s=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; s+=v*v; }
        const rms=Math.sqrt(s/data.length);
        const assist = Math.min(0.25, rms*0.6);

        level = level*0.6 + (target+assist)*0.4;
        setJawEnergy(Math.max(0, Math.min(1, level)));

        raf = requestAnimationFrame(tick);
      };
      raf = requestAnimationFrame(tick);
    }catch(e){ cleanup(false); }
  });
}

let speakQ = Promise.resolve();
let talkGen = 0; // generation id for active talk stream
function speakWithBrowser(sentence){
  return new Promise((resolve)=>{
  // Disabled to prevent male browser voice fallback; resolve immediately.
  return resolve();
  });
}

// Strip labels, stage cues, and formatting artifacts from TTS text
function sanitizeCaption(input){
  let s = String(input||'');
  
  // Remove name prefixes like "Rem:", "Assistant:", etc.
  s = s.replace(/^\s*(?:rem|assistant|ai|bot|system)\s*:\s*/i, '');
  
  // Remove asterisk-based stage directions like *smiles*, *waves*
  s = s.replace(/\*[^*]*\*/g, ' ');
  
  // Remove square-bracket stage directions like [smiles]
  s = s.replace(/\[[^\]]*\]/g, ' ');
  
  // Remove short parenthetical cues like (smiles), (laughs), (beat)
  s = s.replace(/\(([^)]{1,24})\)/g, (m, inner)=> (/^[a-zA-Z\s]+$/.test(inner) ? ' ' : m));
  
  // Remove leading labels like Title:, Summary:, Chorus -, Verse ‚Äî, etc.
  s = s.replace(/^\s*(?:title|subtitle|summary|note|action|directions?|stage|heading|scene|lyrics|chorus|verse|bridge|intro|outro)\s*:\s*/i, '');
  s = s.replace(/^\s*(?:title|subtitle|summary|note|action|directions?|stage|heading|scene|lyrics|chorus|verse|bridge|intro|outro)\s*[-‚Äì‚Äî]\s*/i, '');
  
  // Collapse whitespace and stray punctuation from removals
  s = s.replace(/\s{2,}/g, ' ').replace(/\s+([,.;:!?])/g, '$1').trim();
  return s;
}

function enqueueSpeak(sentence){
  const s = (sentence||'').trim(); if(!s) return;
  const cleaned = sanitizeCaption(s); if(!cleaned) return;
  speakQ = speakQ.then(async ()=>{
    try{
      const {audio_b64, marks} = await ttsFull(cleaned);
      if(!audio_b64){ throw new Error('no-audio'); }
      await playAudioWithVisemes(audio_b64, marks || []);
    }catch(e){
  if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){ return; }
  console.warn('Server TTS failed; skipping speech to avoid browser voice', e);
  // Intentionally skip browser speech so voice never changes from Ruth
    }
  });
}

/* ====== Subtitles + panel toggle ====== */
let subTimer; function showSubtitle(text, ttl=4000){
  const t = sanitizeCaption(text);
  if(!t){ elements.subtitle.classList.remove('show'); return; }
  elements.subtitle.textContent = t; elements.subtitle.classList.add('show');
  if(subTimer) clearTimeout(subTimer);
  subTimer = setTimeout(()=>elements.subtitle.classList.remove('show'), ttl);
}
elements.hambtn.onclick = ()=>{ elements.panel.classList.toggle('open'); };

document.addEventListener('click', (ev)=>{
  if(!elements.panel.classList.contains('open')) return;
  if(elements.panel.contains(ev.target) || elements.hambtn.contains(ev.target)) return;
  elements.panel.classList.remove('open');
});

document.addEventListener('keydown', (ev)=>{
  if(ev.key === 'Escape'){ elements.panel.classList.remove('open'); }
});

/* ====== Streaming chat (with sentence-level TTS) ====== */
async function talk(text){
  const myGen = ++talkGen;
  stopSpeaking();
  const q = (text||'').trim(); if(!q) return;
  try{ lastLangHint = detectLang(q) || lastLangHint; }catch{}
  add(q,'user');

  const bubble = document.createElement('div'); bubble.className='bubble bot'; bubble.textContent=''; elements.log.appendChild(bubble);
  let showedTyping = false; let typingTimer = setTimeout(()=>{ if(!showedTyping){ elements.log.appendChild(typingEl); typingEl.scrollIntoView({behavior:'smooth', block:'end'}); showedTyping=true; } }, 280);

  let buf=''; const dec=new TextDecoder();
  try{
    // Create a fresh controller for this stream and store it globally for interruption
    // Add a client-side timeout to avoid hanging streams
    const streamCtrl = new AbortController();
    curStreamCtrl = streamCtrl;
  const streamTimeout = setTimeout(()=>{ try{ streamCtrl.abort(); }catch{} }, 40000);
  const r = await fetch('/api/chat_stream', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text:q, session_id:'local-1', style: selectedStyle}), signal: streamCtrl.signal});
    if(!r.ok){ throw new Error('stream-status-'+r.status); }
    const reader = r.body.getReader(); let leftover='';
    while(true){
      const {value, done} = await reader.read();
      if(done){ break; }
      if(myGen !== talkGen){ break; }
      // Remove typing indicator upon first chunk
      if(showedTyping){ typingEl.remove(); showedTyping=false; clearTimeout(typingTimer); }
      leftover += dec.decode(value, {stream:true});
      const lines = leftover.split('\n'); leftover = lines.pop();
      for(const line of lines){
        if(!line.trim()) continue;
        const {delta='', error} = JSON.parse(line);
        if(error){
          bubble.textContent += ` [${error}]`;
          if(/Chat busy|Bedrock error|Stream failure/i.test(error)){
            throw new Error('fallback-chat');
          }
          continue;
        }
  bubble.textContent += delta; buf += delta; showSubtitle(bubble.textContent.slice(-220));

        const m = buf.match(/(.+?[.!?][)"']?\s)/);
        if(m && m[1].trim().length>3){ enqueueSpeak(m[1]); buf = buf.slice(m[1].length); }
      }
    }
  // Ensure typing indicator is cleared if still present
  try{ if(showedTyping){ typingEl.remove(); showedTyping=false; } }catch{}; clearTimeout(typingTimer);
  if(myGen !== talkGen){ clearTimeout(streamTimeout); curStreamCtrl = null; return; }
  clearTimeout(streamTimeout);
  if(buf.trim()) { showSubtitle(buf.trim()); try{ lastLangHint = detectLang(buf) || lastLangHint; }catch{}; enqueueSpeak(buf.trim()); buf=''; }
    await speakQ;
    curStreamCtrl = null;
  }catch(e){
  try{ if(showedTyping){ typingEl.remove(); } }catch{}; clearTimeout(typingTimer);
    console.error(e);
    if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){
      // Interrupted: do not fallback or enqueue; just stop cleanly
      curStreamCtrl = null;
      return;
    }
    // Small backoff then fallback to non-streaming
    await new Promise(res=>setTimeout(res, 250));
  // Add a timeout for non-streaming as well
  const nonCtrl = new AbortController(); const nonTimeout = setTimeout(()=>{ try{ nonCtrl.abort(); }catch{} }, 12000);
  const rr = await fetch('/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text:q, session_id:'local-1', style: selectedStyle}), signal: nonCtrl.signal});
    const dd = await rr.json(); bubble.textContent = dd.reply || "I'm here.";
  clearTimeout(nonTimeout);
    showSubtitle(bubble.textContent); enqueueSpeak(bubble.textContent); await speakQ;
    curStreamCtrl = null;
  }
}

elements.send.onclick = ()=>{ 
  const t = elements.inp.value.trim(); 
  if(t){ 
    triggerExpression('thinking');
    setEngagement(0.8);
    talk(t); 
    elements.inp.value=''; 
  } 
};
elements.inp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); elements.send.click(); } });

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recog, localCtx;
let listening = false; // track mic listening state
let ptt = { enabled: false, key: ' ' }; // push-to-talk (Space)
const ASR_LANGS = { en: 'en-US', es: 'es-ES', 'es-mx': 'es-MX', fr: 'fr-FR', 'fr-ca': 'fr-CA', hi: 'hi-IN' };
function resolveAsrLang(){
  if(selectedLang && selectedLang !== 'auto') return ASR_LANGS[selectedLang] || 'en-US';
  return ASR_LANGS[lastLangHint] || 'en-US';
}
function beep(freq=880, ms=120){
  try{
    localCtx = localCtx || new (window.AudioContext||window.webkitAudioContext)();
    const o=localCtx.createOscillator(), g=localCtx.createGain();
    o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(localCtx.destination);
    g.gain.setValueAtTime(0.0001, localCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.25, localCtx.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, localCtx.currentTime+ms/1000);
    o.start(); o.stop(localCtx.currentTime+ms/1000);
  }catch{}
}
function setMicListening(on){
  listening = !!on;
  elements.micdot.classList.toggle('on', on);
  elements.miclabel.textContent = on ? 'Listening‚Ä¶' : 'Idle';
  if(on && speaking) stopSpeaking();
}
function startMic(){
  if(!SpeechRecognition){ alert("Use Chrome/Edge for live speech. I can add Whisper fallback next."); return; }
  if(recog || listening){ return; }
  const r = new SpeechRecognition();
  recog = r; r.lang = resolveAsrLang(); r.interimResults=true; r.continuous=true;
  let buffer=''; let lastFinalAt=0; const DEBOUNCE_MS=250;
  r.onstart = ()=>{ elements.mic.disabled=true; elements.stop.disabled=false; setMicListening(true); 
    elements.miclabel.textContent = 'Listening'; elements.micdot.classList.add('on');
    document.body.classList.add('breathing'); triggerExpression('surprise', 0.5);
    try{ beep(820,120); }catch{} };
  r.onresult = (ev)=>{
    // Ignore any recognition results for a brief window after TTS ends
  // Don't interrupt active TTS mid-utterance
  if(speaking || performance.now() < suppressASRUntil){ return; }
    let gotFinal = false;
    for(let i=ev.resultIndex;i<ev.results.length;i++){
      const rr=ev.results[i]; if(rr.isFinal){ buffer += ' '+rr[0].transcript; gotFinal=true; }
    }
    if(gotFinal){
      const now = performance.now();
      if(now - lastFinalAt < DEBOUNCE_MS){ return; }
      lastFinalAt = now;
      const cleaned = buffer.trim(); if(cleaned){ talk(cleaned); buffer=''; }
    }
  };
  r.onend = ()=>{ elements.mic.disabled=false; elements.stop.disabled=true; setMicListening(false); 
    elements.miclabel.textContent = 'Ready'; elements.micdot.classList.remove('on');
    document.body.classList.remove('breathing'); 
    try{ beep(480,120); }catch{}; recog = null; };
  r.onerror = e=> console.warn(e);
  try{ r.start(); }catch(e){ console.warn('recog.start failed', e); }
}
function stopMic(){ try{ if(recog){ recog.stop(); } }catch(e){}
}
elements.mic.onclick = ()=> startMic();
elements.stop.onclick = ()=>{
  autoResumeMic = false;
  try{ if(recog) recog.stop(); }catch{}
  stopSpeaking();
};
const pttBtn = document.getElementById('pttbtn');
function updatePttBtn(){
  if(!pttBtn) return;
  pttBtn.style.outline = ptt.enabled ? '2px solid var(--green)' : '';
  pttBtn.textContent = ptt.enabled ? 'PTT ‚Ä¢ On' : 'PTT';
}
pttBtn?.addEventListener('click', ()=>{ ptt.enabled = !ptt.enabled; updatePttBtn(); try{ localStorage.setItem('pref-ptt', ptt.enabled?'1':'0'); }catch{} });
// Restore PTT pref
try{ ptt.enabled = localStorage.getItem('pref-ptt')==='1'; }catch{}
updatePttBtn();
// PTT keyboard: hold Space to talk
window.addEventListener('keydown', (e)=>{
  if(!ptt.enabled) return;
  if(e.key === ' ' && !e.repeat){
    // Start mic when space is pressed
    if(!listening) startMic();
  }
}, {passive:true});
window.addEventListener('keyup', (e)=>{
  if(!ptt.enabled) return;
  if(e.key === ' '){
    // Stop mic when space is released
    if(listening) stopMic();
  }
}, {passive:true});
elements.langsel.addEventListener('change', ()=>{
  selectedLang = elements.langsel.value || 'auto';
  try{
    if(recog){ recog.stop(); setTimeout(()=>{ startMic(); }, 200); }
  }catch{}
});

async function doSingFromInput(){
  const lyrics = (elements.singinp?.value||'').trim();
  if(!lyrics){ add('Type lyrics in the Sing box.','bot'); return; }
  stopSpeaking();
  try{
    const {audio_b64, marks} = await singOnce(lyrics);
    await playAudioWithVisemes(audio_b64, marks||[]);
  }catch(e){ console.warn(e); add('Singing failed. Please try again.','bot'); }
}
elements.sing.onclick = async ()=>{
  elements.panel.classList.add('open');
  elements.singinp?.focus();
  if((elements.singinp?.value||'').trim()){ doSingFromInput(); }
};
elements.singGo?.addEventListener('click', ()=>{ doSingFromInput(); });

// Quick knowledge card button
document.getElementById('cardBtn')?.addEventListener('click', async ()=>{
  const topic = (inp.value.trim() || 'a surprising science fact');
  const prompt = `Create a concise knowledge card about ${topic}. Include: Title, 3 bullet points, a one-line takeaway.`;
  add(`Card: ${topic}`,'user');
  try{
    const r = await fetch('/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text: prompt, session_id:'local-1', style: selectedStyle})});
    const d = await r.json();
    const card = document.createElement('div'); card.className='bubble bot'; card.innerHTML = (d.reply||'').replace(/\n/g,'<br>');
    logEl.appendChild(card); card.scrollIntoView({behavior:'smooth', block:'end'});
    showSubtitle('Here‚Äôs a quick card'); enqueueSpeak(d.reply||'Here is a quick card.');
  }catch(e){ console.warn(e); }
});
function dolly(f){
  try{
    if(controls && typeof controls.dollyIn === 'function'){
      if(f>1){ controls.dollyIn(f); } else { controls.dollyOut(1/f); }
      controls.update(); return;
    }
  }catch{}
  try{
    const to = new THREE.Vector3();
    to.copy(controls?.target || new THREE.Vector3(0,0,0));
    const v = new THREE.Vector3().subVectors(camera.position, to).multiplyScalar(1/f);
    camera.position.copy(v.add(to)); camera.updateProjectionMatrix(); controls?.update();
  }catch{}
}
elements.zoomIn?.addEventListener('click', ()=> dolly(1.2));
elements.zoomOut?.addEventListener('click', ()=> dolly(1/1.2));
elements.zoomReset?.addEventListener('click', ()=>{ try{ controls.reset(); }catch{}; try{ if(root) frameObject(root); }catch{} });

// Initialize all UI functionality
function initializeUI() {
  console.log('üéØ Initializing UI functionality...');
  
  // Verify essential elements
  const requiredElements = ['hambtn', 'panel', 'log', 'inp', 'send'];
  const missingElements = requiredElements.filter(id => !document.getElementById(id));
  if (missingElements.length > 0) {
    console.error('‚ùå Missing essential elements:', missingElements);
  }
  
  // Make sure hamburger menu works
  try {
    const hambtn = document.getElementById('hambtn');
    const panel = document.getElementById('panel');
    if (hambtn && panel) {
      hambtn.addEventListener('click', () => {
        panel.classList.toggle('open');
        console.log('üçî Hamburger menu toggled, panel open:', panel.classList.contains('open'));
      });
      console.log('‚úÖ Hamburger menu initialized');
    } else {
      console.error('‚ùå Hamburger menu elements not found:', { hambtn: !!hambtn, panel: !!panel });
    }
  } catch (error) {
    console.error('‚ùå Error setting up hamburger menu:', error);
  }
  
  // Style buttons (personality modes)
  try {
    for (const b of styleButtons()) {
      console.log('üé≠ Setting up style button:', b.textContent);
      b.addEventListener('click', () => {
        const chosen = b.getAttribute('data-style') || null;
        const wasSelected = selectedStyle === chosen;
        
        // Toggle off if clicking the same style again
        selectedStyle = wasSelected ? null : chosen;
        
        // Visual toggle
        styleButtons().forEach(x => { x.style.outline = ''; x.style.boxShadow = ''; });
        if (selectedStyle) { 
          b.style.outline = '2px solid var(--green)'; 
          b.style.boxShadow = '0 0 8px rgba(0, 214, 143, 0.3)';
        }
        
        // Update mode display
        const modeDisplay = document.getElementById('current-mode');
        const modeText = selectedStyle ? `${selectedStyle.charAt(0).toUpperCase() + selectedStyle.slice(1)}` : 'Default';
        if (modeDisplay) modeDisplay.textContent = `Mode: ${modeText}`;
        
        // Clear feedback
        showSubtitle(`üí¨ ${selectedStyle ? `${selectedStyle} mode active` : 'default mode'}`, 2000);
        
        // Store preference
        try { localStorage.setItem('selected-style', selectedStyle || ''); } catch {}
        
        console.log('üé≠ Style changed to:', selectedStyle || 'default');
      });
    }
    
    // Restore saved style preference
    try {
      const savedStyle = localStorage.getItem('selected-style');
      if (savedStyle && savedStyle !== '') {
        selectedStyle = savedStyle;
        const btn = document.querySelector(`[data-style="${savedStyle}"]`);
        if (btn) { 
          btn.style.outline = '2px solid var(--green)';
          btn.style.boxShadow = '0 0 8px rgba(0, 214, 143, 0.3)';
        }
        const modeDisplay = document.getElementById('current-mode');
        if (modeDisplay) modeDisplay.textContent = `Mode: ${savedStyle.charAt(0).toUpperCase() + savedStyle.slice(1)}`;
        console.log('üé≠ Restored style:', savedStyle);
      }
    } catch {}
    
    // Reset style button
    document.getElementById('resetStyle')?.addEventListener('click', () => {
      selectedStyle = null;
      styleButtons().forEach(x => { x.style.outline = ''; x.style.boxShadow = ''; });
      const modeDisplay = document.getElementById('current-mode');
      if (modeDisplay) modeDisplay.textContent = 'Mode: Default';
      showSubtitle('üí¨ default mode', 1500);
      try { localStorage.setItem('selected-style', ''); } catch {}
      console.log('üé≠ Style reset to default');
    });
  } catch (error) {
    console.error('‚ùå Error setting up style buttons:', error);
  }
  
  // Quick action buttons (data-say)
  try {
    for (const b of suggestionButtons()) {
      console.log('‚ö° Setting up quick action button:', b.textContent);
      b.addEventListener('click', () => {
        const v = b.getAttribute('data-say') || ''; 
        if (v) { 
          triggerExpression('smile', 0.8);
          setEngagement(0.9);
          talk(v);
          console.log('‚ö° Quick action triggered:', v);
        }
      });
    }
  } catch (error) {
    console.error('‚ùå Error setting up quick action buttons:', error);
  }
  
  console.log('‚úÖ UI initialization complete');
}

// Initialize everything when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeUI);
} else {
  initializeUI();
}

['pointerdown','keydown'].forEach(evt=>{
  window.addEventListener(evt, ()=>{
    try{ if(audioCtx && audioCtx.state!=='running'){ audioCtx.resume(); } }catch{}
    try{ if(window.speechSynthesis && window.speechSynthesis.paused){ window.speechSynthesis.resume?.(); } }catch{}
    try{
      if(!window.__unlocked && (window.AudioContext||window.webkitAudioContext)){
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const node = ctx.createBufferSource(); node.buffer = ctx.createBuffer(1,1,22050); node.connect(ctx.destination); node.start(0);
        window.__unlocked = true;
      }
    }catch{}
  }, {passive:true});
});
</script>
</body>
</html>